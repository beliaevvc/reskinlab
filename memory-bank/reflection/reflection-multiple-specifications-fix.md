# Reflection: Fix Tasks Creation for Multiple Specifications

**Date:** 4 февраля 2026
**Task ID:** multiple-specifications-fix
**Complexity:** Level 2 (Enhancement with DB changes)

---

## Summary

Исправлен критический баг в системе автоматического создания задач: при дозаказе работ клиентом в рамках существующего проекта задачи не создавались для новых спецификаций.

**Root Cause:** Функция `auto_create_tasks_on_first_payment()` проверяла "есть ли уже задачи в проекте" вместо "созданы ли задачи для ЭТОЙ КОНКРЕТНОЙ спецификации".

---

## What Went Well

### 1. Быстрая диагностика проблемы
- Анализ существующего кода триггера сразу выявил проблемную логику
- Чёткое понимание цепочки: `payment → invoice → offer → specification → tasks`

### 2. Правильное архитектурное решение
- Добавление `source_specification_id` в таблицу `tasks` — чистое и расширяемое решение
- Позволяет отслеживать происхождение каждой задачи
- Поддерживает сценарий дозаказов без переписывания всей логики

### 3. Backfill существующих данных
- Миграция корректно связала старые задачи с их спецификациями
- Использование цепочки `invoice → offer → specification` для определения связи

### 4. Комплексное исправление
- Исправлена не только БД, но и фронтенд отображение
- Добавлена инвалидация кеша для `['project-offers']`

---

## Challenges Encountered

### 1. Отладка отображения спецификации в UI
**Проблема:** После применения миграции старые задачи показывали неправильную спецификацию (v2 вместо v1).

**Причина:** `TaskDetailModal` искал первую non-draft спецификацию в массиве (отсортированном по version DESC), а не связанную с задачей.

**Решение:** Изменена логика в `TaskDetailModal.jsx`:
```javascript
const activeSpec = task?.source_specification_id 
  ? specifications?.find(s => s.id === task.source_specification_id)
  : (specifications?.find(s => s.status !== 'draft') || specifications?.[0]);
```

### 2. Кеширование офферов
**Проблема:** После создания задач оффер появлялся только после перезагрузки страницы.

**Причина:** `useProjectOffers` использовал query key `['project-offers', ...]`, который не инвалидировался в `useConfirmPayment`.

**Решение:** Добавлена инвалидация `['project-offers']` в `useInvoices.js`.

### 3. Верификация данных
- Потребовалась проверка данных в БД через SQL запросы
- Подтвердили, что backfill сработал корректно

---

## Lessons Learned

### 1. Query Key Consistency
При создании новых хуков с кастомными query keys нужно:
- Документировать их использование
- Добавлять инвалидацию во ВСЕ связанные мутации
- Рассмотреть использование фабрики query keys

### 2. Связи между сущностями
Для задач важно хранить `source_specification_id`, а не полагаться на косвенные связи через проект. Это позволяет:
- Корректно отображать связанные данные
- Поддерживать множественные спецификации в проекте
- Отслеживать происхождение задач

### 3. Тестирование на реальных данных
- Backfill может работать по-разному в зависимости от данных
- Важно верифицировать результаты SQL запросами

### 4. Поэтапная отладка
Проблема имела несколько слоёв:
1. БД триггер (основная логика)
2. Frontend отображение (TaskDetailModal)
3. Кеширование (React Query)

Каждый слой требовал отдельного исправления.

---

## Technical Improvements

### Database
- Новая колонка `tasks.source_specification_id` с FK на `specifications`
- Индекс для быстрого поиска задач по спецификации
- Обновлённая функция триггера с per-specification проверкой

### Frontend
- `TaskDetailModal.jsx` — использует `source_specification_id` для отображения
- `useInvoices.js` — инвалидация `['project-offers']`

---

## Process Improvements

### 1. Checklist для изменений с кешированием
При добавлении новых query keys:
- [ ] Документировать query key
- [ ] Найти все места где нужна инвалидация
- [ ] Добавить инвалидацию в связанные мутации
- [ ] Протестировать обновление данных без reload

### 2. Миграции с backfill
При создании миграций с backfill:
- [ ] Проверить логику на тестовых данных
- [ ] Добавить RAISE NOTICE для отладки
- [ ] Верифицировать результат SQL запросом
- [ ] Учесть edge cases (NULL values, пустые данные)

---

## Files Modified

### New Files
- `calculator/supabase/migrations/036_fix_tasks_for_multiple_specifications.sql`

### Modified Files
- `calculator/src/components/tasks/TaskDetailModal.jsx` — логика определения спецификации
- `calculator/src/hooks/useInvoices.js` — инвалидация project-offers

---

## Next Steps

1. **Мониторинг** — убедиться, что новые дозаказы работают корректно в production
2. **Документация** — обновить архитектурную документацию с новой связью tasks ↔ specifications
3. **Query Keys** — рассмотреть создание централизованного файла с фабрикой query keys

---

## Conclusion

Задача решена комплексно: исправлена логика в БД, обновлено отображение на фронтенде, добавлена инвалидация кеша. Архитектурное решение (добавление `source_specification_id`) является чистым и масштабируемым, позволяя поддерживать множественные спецификации в рамках одного проекта.
